Теперь понял, тебе нужно, чтобы в каждой итерации сначала выполнялась первая функция, и только после её завершения вызывалась вторая, а в следующей итерации снова начиналось с первой функции. Если обе функции зависят от выполнения какой-то операции, и они должны запускаться последовательно, то правильным решением будет использовать `async`/`await` или подход с `Promise`.

Вот правильный пример, где **первая функция** вызывается, завершается, и только потом вызывается **вторая функция**:

```typescript
export class YourComponent {
  constructor() {
    this.runLoop();
  }

  async runLoop() {
    for (let i = 1; i <= 9; i++) {
      await this.firstFunc(i);  // Ждем завершения первой функции
      await this.secondFunc(i); // Затем вызываем вторую функцию
    }
  }

  async firstFunc(i: number): Promise<void> {
    // Логика первой функции
    console.log(`Первая функция завершена для i = ${i}`);
    return Promise.resolve(); // Завершение первой функции
  }

  async secondFunc(i: number): Promise<void> {
    // Логика второй функции
    console.log(`Вторая функция завершена для i = ${i}`);
    return Promise.resolve(); // Завершение второй функции
  }
}
```

**Что происходит:**
1. `runLoop()` — асинхронная функция, которая вызывает сначала `firstFunc(i)` и **ждет** её завершения с помощью `await`.
2. После завершения первой функции вызывается `secondFunc(i)` с помощью `await`, гарантируя, что она запускается **после** первой.
3. Этот процесс повторяется для каждого значения `i` от 1 до 9.

Таким образом, в каждой итерации `firstFunc` выполняется первой и завершает свою работу, и только после этого вызывается `secondFunc`.