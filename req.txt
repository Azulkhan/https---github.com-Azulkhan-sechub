Да, вы можете выполнить POST запрос с данными в формате `x-www-form-urlencoded` на Lua с использованием библиотеки HTTP, такой как `lua-http` или `socket.http`. Пример использования библиотеки `socket.http` для отправки такого запроса:

```lua
local http = require("socket.http")
local ltn12 = require("ltn12")

local url = "http://example.com/post"  -- замените на ваш URL
local params = "key1=value1&key2=value2"  -- ваши параметры

local response_body = {}
local res, code, response_headers, status = http.request{
    url = url,
    method = "POST",
    headers = {
        ["Content-Type"] = "application/x-www-form-urlencoded",
        ["Content-Length"] = tostring(#params)
    },
    source = ltn12.source.string(params),
    sink = ltn12.sink.table(response_body)
}

if res == 1 then
    print("Response body: " .. table.concat(response_body))
else
    print("HTTP request failed with code: " .. code)
end
```

Этот пример использует библиотеку `socket.http` для отправки POST запроса с параметрами в формате `x-www-form-urlencoded`. Замените URL и параметры на нужные вам значения.

Если вам нужно использовать библиотеку `lua-http`, вот пример:

```lua
local http_request = require "http.request"
local http_util = require "http.util"

local url = "http://example.com/post"  -- замените на ваш URL
local params = "key1=value1&key2=value2"  -- ваши параметры

local headers = {
    ["Content-Type"] = "application/x-www-form-urlencoded",
    ["Content-Length"] = tostring(#params)
}

local req = http_request.new_from_uri(url)
req.headers:upsert(":method", "POST")
for k, v in pairs(headers) do
    req.headers:upsert(k, v)
end

req:set_body(params)

local headers, stream = req:go()
local body, err = stream:get_body_as_string()

if body then
    print("Response body: " .. body)
else
    print("HTTP request failed with error: " .. err)
end
```

Этот пример использует библиотеку `lua-http` для выполнения POST запроса. Замените URL и параметры на свои.