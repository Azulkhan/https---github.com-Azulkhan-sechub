Хорошо, вот пример POST запроса на Lua, где URL принимает два значения, и сервер возвращает один ответ. Для простоты, будем использовать библиотеку `socket.http`.

```lua
local http = require("socket.http")
local ltn12 = require("ltn12")

local url = "http://example.com/post"  -- замените на ваш URL
local params = "key1=value1&key2=value2"  -- замените на ваши параметры

local response_body = {}
local res, code, response_headers, status = http.request{
    url = url,
    method = "POST",
    headers = {
        ["Content-Type"] = "application/x-www-form-urlencoded",
        ["Content-Length"] = tostring(#params)
    },
    source = ltn12.source.string(params),
    sink = ltn12.sink.table(response_body)
}

if res == 1 then
    local response = table.concat(response_body)
    print("Response body: " .. response)
else
    print("HTTP request failed with code: " .. code)
end
```

Этот код делает следующее:
1. Устанавливает URL для запроса.
2. Создаёт строку параметров в формате `x-www-form-urlencoded`.
3. Создаёт пустую таблицу для хранения тела ответа.
4. Выполняет HTTP POST запрос с указанными параметрами.
5. Печатает тело ответа, если запрос был успешным, или код ошибки, если запрос не удался.

Если вам нужно использовать библиотеку `lua-http`, вот аналогичный пример:

```lua
local http_request = require "http.request"
local http_util = require "http.util"

local url = "http://example.com/post"  -- замените на ваш URL
local params = "key1=value1&key2=value2"  -- замените на ваши параметры

local headers = {
    ["Content-Type"] = "application/x-www-form-urlencoded",
    ["Content-Length"] = tostring(#params)
}

local req = http_request.new_from_uri(url)
req.headers:upsert(":method", "POST")
for k, v in pairs(headers) do
    req.headers:upsert(k, v)
end

req:set_body(params)

local headers, stream = req:go()
local body, err = stream:get_body_as_string()

if body then
    print("Response body: " .. body)
else
    print("HTTP request failed with error: " .. err)
end
```

Этот код также делает HTTP POST запрос и выводит тело ответа или сообщение об ошибке. Замените URL и параметры на свои значения.



Конечно! Вот пример выполнения POST-запроса с данными в формате `x-www-form-urlencoded` на языке Go с использованием стандартной библиотеки `net/http`:

```go
package main

import (
	"bytes"
	"fmt"
	"net/http"
	"net/url"
)

func main() {
	// Замените на ваш URL
	urlStr := "http://example.com/post"

	// Задайте параметры запроса
	data := url.Values{}
	data.Set("key1", "value1")
	data.Set("key2", "value2")

	// Создание запроса
	req, err := http.NewRequest("POST", urlStr, bytes.NewBufferString(data.Encode()))
	if err != nil {
		fmt.Println("Error creating request:", err)
		return
	}

	// Установка заголовков
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	// Выполнение запроса
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Error sending request:", err)
		return
	}
	defer resp.Body.Close()

	// Чтение ответа
	buf := new(bytes.Buffer)
	buf.ReadFrom(resp.Body)
	response := buf.String()

	// Вывод ответа
	fmt.Println("Response body:", response)
}
```

Этот код делает следующее:
1. Устанавливает URL для запроса.
2. Создаёт объект `url.Values` для параметров запроса.
3. Создаёт новый HTTP POST запрос с указанными параметрами.
4. Устанавливает заголовок `Content-Type` как `application/x-www-form-urlencoded`.
5. Выполняет запрос с помощью `http.Client`.
6. Читает и выводит тело ответа.

Замените `urlStr`, а также параметры `key1` и `key2` на нужные вам значения.